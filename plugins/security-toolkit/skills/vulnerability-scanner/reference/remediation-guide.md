# Remediation Guide

## Contents
- Injection fixes
- XSS prevention
- Authentication hardening
- Cryptography best practices
- Access control implementation

## Injection Fixes

### SQL Injection

**Use parameterized queries:**

```javascript
// Node.js with mysql2
const [rows] = await connection.execute(
  'SELECT * FROM users WHERE id = ?',
  [userId]
);

// Node.js with pg
const result = await client.query(
  'SELECT * FROM users WHERE id = $1',
  [userId]
);
```

```python
# Python with psycopg2
cursor.execute(
    "SELECT * FROM users WHERE id = %s",
    (user_id,)
)

# SQLAlchemy ORM
User.query.filter_by(id=user_id).first()
```

### Command Injection

**Avoid shell=True, use arrays:**

```python
# BAD
subprocess.call(f"ls {user_dir}", shell=True)

# GOOD
subprocess.call(["ls", user_dir])
```

```javascript
// BAD
exec(`ls ${userDir}`);

// GOOD
execFile('ls', [userDir]);
```

## XSS Prevention

### React

```javascript
// BAD
<div dangerouslySetInnerHTML={{__html: userInput}} />

// GOOD - Use text content
<div>{userInput}</div>

// If HTML needed, sanitize first
import DOMPurify from 'dompurify';
<div dangerouslySetInnerHTML={{__html: DOMPurify.sanitize(userInput)}} />
```

### Vanilla JavaScript

```javascript
// BAD
element.innerHTML = userInput;

// GOOD
element.textContent = userInput;
```

### Content Security Policy

Add CSP header:
```
Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'
```

## Authentication Hardening

### Password Storage

```python
# Use bcrypt
import bcrypt

# Hash password
hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt(12))

# Verify password
bcrypt.checkpw(password.encode(), hashed)
```

```javascript
// Node.js with bcrypt
const bcrypt = require('bcrypt');

// Hash
const hash = await bcrypt.hash(password, 12);

// Verify
const match = await bcrypt.compare(password, hash);
```

### Session Security

```javascript
// Express session config
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true,      // HTTPS only
    httpOnly: true,    // No JS access
    sameSite: 'strict',
    maxAge: 3600000    // 1 hour
  }
}));
```

## Cryptography Best Practices

### Use Strong Algorithms

| Purpose | Recommended | Avoid |
|---------|-------------|-------|
| Password hashing | bcrypt, Argon2 | MD5, SHA1 |
| Encryption | AES-256-GCM | DES, RC4 |
| Signing | RSA-2048+, Ed25519 | RSA-1024 |
| Hashing | SHA-256+ | MD5, SHA1 |

### Secure Random Generation

```python
# Python
import secrets
token = secrets.token_hex(32)
```

```javascript
// Node.js
const crypto = require('crypto');
const token = crypto.randomBytes(32).toString('hex');
```

## Access Control

### Authorization Checks

```javascript
// Always verify ownership
async function getDocument(userId, docId) {
  const doc = await Document.findById(docId);
  
  if (!doc) throw new NotFoundError();
  if (doc.ownerId !== userId) throw new ForbiddenError();
  
  return doc;
}
```

### Path Traversal Prevention

```javascript
const path = require('path');

function safeReadFile(baseDir, filename) {
  const safePath = path.join(baseDir, path.basename(filename));
  
  // Verify path is within allowed directory
  if (!safePath.startsWith(baseDir)) {
    throw new Error('Invalid path');
  }
  
  return fs.readFileSync(safePath);
}
```
